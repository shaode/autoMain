// Generated by LiveScript 1.2.0
(function(){
  var ref$, primitiveOnlyAttributes, eitherAttributes, all, tail, getNodeAtPath, toString$ = {}.toString, slice$ = [].slice;
  ref$ = require('grasp-syntax-javascript'), primitiveOnlyAttributes = ref$.primitiveOnlyAttributes, eitherAttributes = ref$.eitherAttributes;
  ref$ = require('prelude-ls'), all = ref$.all, tail = ref$.tail;
  getNodeAtPath = require('./common').getNodeAtPath;
  function matchNode(results, query, mainNode){
    var key, val, ref$;
    if (eq(mainNode, query)) {
      results.push(mainNode);
    }
    for (key in mainNode) {
      val = mainNode[key];
      if ((key !== 'loc' && key !== 'start' && key !== 'end' && key !== '_named') && ((ref$ = toString$.call(val).slice(8, -1)) === 'Object' || ref$ === 'Array')) {
        matchNode(results, query, val);
      }
    }
    function eq(targetNode, selectorNode){
      var selectorNodeType, prop;
      selectorNodeType = toString$.call(selectorNode).slice(8, -1);
      if (selectorNode === targetNode) {
        return true;
      } else if (selectorNodeType !== toString$.call(targetNode).slice(8, -1)) {
        return false;
      } else if (selectorNodeType === 'Object') {
        if (selectorNode.type === 'Grasp') {
          return matchSpecial(targetNode, selectorNode);
        } else {
          for (prop in targetNode) {
            if (prop !== 'loc' && prop !== 'start' && prop !== 'end' && prop !== '_named') {
              if (!eq(targetNode[prop], selectorNode[prop])) {
                return false;
              }
            }
          }
          return true;
        }
      } else if (selectorNodeType === 'Array') {
        return matchArray(selectorNode, targetNode);
      } else {
        return false;
      }
    }
    function matchArray(pattern, input){
      var patternLen, that, ref$, patternFirst, patternRest, inputFirst, inputRest, arrayWildcardName, wildcardName;
      patternLen = pattern.length;
      if (patternLen === 0) {
        return input.length === 0;
      } else if (patternLen === 1) {
        if (that = isArrayWildcard(pattern[0])) {
          if (that = that.name) {
            mainNode._named == null && (mainNode._named = {});
            (ref$ = mainNode._named)[that] == null && (ref$[that] = []);
            (ref$ = mainNode._named)[that] = ref$[that].concat(input);
          }
          return true;
        } else {
          return input.length === 1 && eq(input[0], pattern[0]);
        }
      } else if (input.length === 0) {
        return false;
      } else {
        patternFirst = pattern[0], patternRest = slice$.call(pattern, 1);
        inputFirst = input[0], inputRest = slice$.call(input, 1);
        if (that = isArrayWildcard(patternFirst)) {
          if (that = that.name) {
            arrayWildcardName = that;
            mainNode._named == null && (mainNode._named = {});
            (ref$ = mainNode._named)[arrayWildcardName] == null && (ref$[arrayWildcardName] = []);
          }
          if (that = eq(inputFirst, patternRest[0])) {
            wildcardName = that;
            if (matchArray(tail(patternRest), inputRest)) {
              return true;
            } else {
              if (toString$.call(wildcardName).slice(8, -1) === 'String') {
                delete mainNode._named[wildcardName];
              }
              return matchArray(pattern, inputRest);
            }
          } else {
            if (arrayWildcardName) {
              mainNode._named[arrayWildcardName].push(inputFirst);
            }
            return matchArray(pattern, inputRest);
          }
        } else {
          return eq(inputFirst, patternFirst) && matchArray(patternRest, inputRest);
        }
      }
    }
    function matchSpecial(targetNode, selectorNode){
      var named, name, that, identMatch, attrMatch;
      switch (selectorNode.graspType) {
      case 'wildcard':
        return true;
      case 'named-wildcard':
        mainNode._named == null && (mainNode._named = {});
        named = mainNode._named;
        name = selectorNode.name;
        if (that = named[name]) {
          if (eq(targetNode, that)) {
            return true;
          } else {
            return false;
          }
        } else {
          named[name] = targetNode;
          return name;
        }
        break;
      case 'node-type':
        return targetNode.type === selectorNode.value;
      case 'matches':
        return in$(targetNode.type, selectorNode.value);
      case 'literal':
        return targetNode.type === 'Literal' && toString$.call(targetNode.value).slice(8, -1) === selectorNode.value;
      case 'compound':
        identMatch = matchSpecial(targetNode, selectorNode.ident);
        attrMatch = all(matchAttr(targetNode), selectorNode.attrs);
        return identMatch && attrMatch;
      }
    }
    function isArrayWildcard(node){
      var cleanNode;
      cleanNode = node.type === 'ExpressionStatement' ? node.expression : node;
      return cleanNode.type === 'Grasp' && cleanNode.graspType === 'array-wildcard' && cleanNode;
    }
    function matchAttr(targetNode){
      return function(attr){
        var node, attrValue, lastPath, ref$;
        node = getNodeAtPath(targetNode, attr.path);
        if (node != null) {
          attrValue = attr.value;
          if (attrValue) {
            lastPath = (ref$ = attr.path)[ref$.length - 1];
            if (in$(lastPath, primitiveOnlyAttributes)) {
              return matchPrimitive(attr.op, node, attrValue);
            } else if (in$(lastPath, eitherAttributes)) {
              return matchEither(attr.op, node, attrValue);
            } else {
              return matchComplex(attr.op, node, attrValue);
            }
          } else {
            return true;
          }
        } else {
          return false;
        }
      };
    }
    function matchPrimitive(op, node, attrValue){
      if (op === '=') {
        return node === attrValue.value;
      } else {
        return node !== attrValue.value;
      }
    }
    function matchComplex(op, node, attrValue){
      if (op === '=') {
        return eq(node, attrValue);
      } else {
        return !eq(node, attrValue);
      }
    }
    function matchEither(op, node, attrValue){
      return matchPrimitive(op, node, attrValue) || matchComplex(op, node, attrValue);
    }
  }
  module.exports = {
    matchNode: matchNode
  };
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
